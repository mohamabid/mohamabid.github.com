<!-- (c) Abid Mohammed 2015 -->
<!-- Apache Licence -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Driving Simulator</title>
    <style type="text/css">
        body {
            width: 100%;
            height: 100%;
            margin: 0;
        }
    </style>
    <script type="text/javascript" charset="UTF-8" src="https://js.api.here.com/v3/3.0/mapsjs-core.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://js.api.here.com/v3/3.0/mapsjs-service.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://js.api.here.com/v3/3.0/mapsjs-ui.js"></script>
    <script type="text/javascript" charset="UTF-8" src="https://js.api.here.com/v3/3.0/mapsjs-mapevents.js"></script>
    <script type="text/javascript" charset="utf-8" src="http://js.api.here.com/v3/3.0/mapsjs-pano.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
</head>
<body>
<div id="map" style="width: 100%"/>
<canvas id="vehicleMarkerCanvas" width="28" height="28" style="display: none;"></canvas>
<script>
    function moveMapTo(map, latLong, zoomLevel) {
        map.setCenter(latLong);
        map.setZoom(zoomLevel);
    }
    function enableTrafficInfo() {
        map.setBaseLayer(defaultLayers.satellite.traffic);
        map.addLayer(defaultLayers.incidents);
    }

    var platform = new H.service.Platform({
        app_id: 'YhvbJSgCHhXzWMatvfl1',
        app_code: 'WrD3YoZ2yXjYrBQRDQPUFQ',
        useCIT: true,
        useHTTPS: false
    });

    $("#map").height($(document).height());
    var zoomLevel = 15;
    var defaultLayers = platform.createDefaultLayers();
    var map = new H.Map(document.getElementById('map'), defaultLayers.satellite.map);
    var behavior = new H.mapevents.Behavior(new H.mapevents.MapEvents(map));
    var ui = H.ui.UI.createDefault(map, defaultLayers);
    moveMapTo(map, {lat: 32.673764, lng: -117.240591}, zoomLevel);
    enableTrafficInfo();
    var startLocation = '41.890922,-87.616806';
    var endLocation = '41.984185,-87.652602';
    $(document).ready(function () {
        calculateRouteFromAtoB();
    });

    $(window).on('resize', function () {
        location.reload();
    });
    var vehicleMarker = createVehicleMarkerCanvas("vehicleMarkerCanvas");

    var activeMarker;
    var currentDrivingLocationIndex = 0;
    var fineDist = 10; //Meters
    var driveInterval = 100; //Millisecond
    var vehicleSpeed = 500;
    var activeIntervalTimer;
    var drivingRoute;
    var activeMarker;
    var dotIcon = new H.map.Icon(vehicleMarker, {anchor: {x: 14, y: 14}});

    function clearGlobals(resetSpeed) {
        clearTimeout(activeIntervalTimer);
        currentDrivingLocationIndex = 0;
        activeMarker = null;
        drivingRoute = null;
        activeIntervalTimer = null;
    }

    function driveThroughRoute(route) {
        try {
            drivingRoute = convertRouteIntoFinerLatLngs(route, fineDist);
            driveInterval = calcTimeInMilliSec(vehicleSpeed, fineDist * 0.000621371);
            activeIntervalTimer = setInterval(function () {
                addAndRemoveMarker()
            }, driveInterval);
        } catch (err) {
            if (activeIntervalTimer) {
                clearTimeout(activeIntervalTimer);
            }
            console.error(err);
        }
    }

    function addAndRemoveMarker() {
        var currentLocation = drivingRoute[currentDrivingLocationIndex];
        var marker;
        if (currentLocation.point) {
            marker = new H.map.Marker({
                lat: currentLocation.point.lat,
                lng: currentLocation.point.lon
            }, {icon: dotIcon});
        } else {
            marker = new H.map.Marker({lat: currentLocation.lat, lng: currentLocation.lon}, {icon: dotIcon});
        }
        map.addObject(marker);
        map.setCenter(marker.getPosition());
        if (activeMarker) {
            map.removeObject(activeMarker);
        }
        activeMarker = marker;
        map.setZoom(16);
        currentDrivingLocationIndex++;
        if (currentDrivingLocationIndex == drivingRoute.length - 1) {
            clearGlobals();
        }
    }

    function pauseDriving() {
        clearTimeout(activeIntervalTimer);
    }

    function calculateRouteFromAtoB() {
        var router = platform.getRoutingService(),
                routeRequestParams = {
                    mode: 'fastest;car',
                    representation: 'display',
                    routeattributes: 'waypoints,summary,shape,legs',
                    maneuverattributes: 'direction,action',
                    waypoint0: startLocation,
                    waypoint1: endLocation
                };
        router.calculateRoute(
                routeRequestParams,
                onRouteSuccess,
                onError
        );
    }

    function onRouteSuccess(result) {
        var route = result.response.route[0];
        addRouteShapeToMap(route);
        driveThroughRoute(route);
    }

    function onError(error) {
        console.log('Error getting route!');
    }

    function addRouteShapeToMap(route) {
        var strip = new H.geo.Strip(),
                routeShape = route.shape,
                polyline;
        routeShape.forEach(function (shapePoint) {
            var parts = shapePoint.split(',');
            strip.pushLatLngAlt(parts[0], parts[1]);
        });
        polyline = new H.map.Polyline(strip, {
            style: {
                lineWidth: 4,
                strokeColor: 'rgba(0, 128, 255, 0.7)'
            }
        });
        map.addObject(polyline);
        map.setViewBounds(polyline.getBounds(), true);
    }

    /**
     * Put all JS dependencies here
     */
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    /*  Geodesy representation conversion functions                       (c) Chris Veness 2002-2015  */
    /*   - www.movable-type.co.uk/scripts/latlong.html                                   MIT Licence  */
    /*                                                                                                */
    /*  Sample usage:                                                                                 */
    /*    var lat = Dms.parseDMS('51° 28′ 40.12″ N');                                                 */
    /*    var lon = Dms.parseDMS('000° 00′ 05.31″ W');                                                */
    /*    var p1 = new LatLon(lat, lon);                                                              */
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    'use strict';


    /**
     * Tools for converting between numeric degrees and degrees / minutes / seconds.
     *
     * @namespace
     */
    var Dms = {};


    // note Unicode Degree = U+00B0. Prime = U+2032, Double prime = U+2033


    /**
     * Parses string representing degrees/minutes/seconds into numeric degrees.
     *
     * This is very flexible on formats, allowing signed decimal degrees, or deg-min-sec optionally
     * suffixed by compass direction (NSEW). A variety of separators are accepted (eg 3° 37′ 09″W).
     * Seconds and minutes may be omitted.
     *
     * @param   {string|number} dmsStr - Degrees or deg/min/sec in variety of formats.
     * @returns {number} Degrees as decimal number.
     */
    Dms.parseDMS = function (dmsStr) {
        // check for signed decimal degrees without NSEW, if so return it directly
        if (typeof dmsStr == 'number' && isFinite(dmsStr)) return Number(dmsStr);

        // strip off any sign or compass dir'n & split out separate d/m/s
        var dms = String(dmsStr).trim().replace(/^-/, '').replace(/[NSEW]$/i, '').split(/[^0-9.,]+/);
        if (dms[dms.length - 1] == '') dms.splice(dms.length - 1);  // from trailing symbol

        if (dms == '') return NaN;

        // and convert to decimal degrees...
        var deg;
        switch (dms.length) {
            case 3:  // interpret 3-part result as d/m/s
                deg = dms[0] / 1 + dms[1] / 60 + dms[2] / 3600;
                break;
            case 2:  // interpret 2-part result as d/m
                deg = dms[0] / 1 + dms[1] / 60;
                break;
            case 1:  // just d (possibly decimal) or non-separated dddmmss
                deg = dms[0];
                // check for fixed-width unseparated format eg 0033709W
                //if (/[NS]/i.test(dmsStr)) deg = '0' + deg;  // - normalise N/S to 3-digit degrees
                //if (/[0-9]{7}/.test(deg)) deg = deg.slice(0,3)/1 + deg.slice(3,5)/60 + deg.slice(5)/3600;
                break;
            default:
                return NaN;
        }
        if (/^-|[WS]$/i.test(dmsStr.trim())) deg = -deg; // take '-', west and south as -ve

        return Number(deg);
    };


    /**
     * Converts decimal degrees to deg/min/sec format
     *  - degree, prime, double-prime symbols are added, but sign is discarded, though no compass
     *    direction is added.
     *
     * @private
     * @param   {number} deg - Degrees to be formatted as specified.
     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.
     * @returns {string} Degrees formatted as deg/min/secs according to specified format.
     */
    Dms.toDMS = function (deg, format, dp) {
        if (isNaN(deg)) return null;  // give up here if we can't make a number from deg

        // default values
        if (format === undefined) format = 'dms';
        if (dp === undefined) {
            switch (format) {
                case 'd':
                case 'deg':
                    dp = 4;
                    break;
                case 'dm':
                case 'deg+min':
                    dp = 2;
                    break;
                case 'dms':
                case 'deg+min+sec':
                    dp = 0;
                    break;
                default:
                    format = 'dms';
                    dp = 0;  // be forgiving on invalid format
            }
        }

        deg = Math.abs(deg);  // (unsigned result ready for appending compass dir'n)

        var dms, d, m, s;
        switch (format) {
            default: // invalid format spec!
            case 'd':
            case 'deg':
                d = deg.toFixed(dp);    // round degrees
                if (d < 100) d = '0' + d; // pad with leading zeros
                if (d < 10) d = '0' + d;
                dms = d + '°';
                break;
            case 'dm':
            case 'deg+min':
                var min = (deg * 60).toFixed(dp); // convert degrees to minutes & round
                d = Math.floor(min / 60);       // get component deg/min
                m = (min % 60).toFixed(dp);     // pad with trailing zeros
                if (d < 100) d = '0' + d;         // pad with leading zeros
                if (d < 10) d = '0' + d;
                if (m < 10) m = '0' + m;
                dms = d + '°' + m + '′';
                break;
            case 'dms':
            case 'deg+min+sec':
                var sec = (deg * 3600).toFixed(dp); // convert degrees to seconds & round
                d = Math.floor(sec / 3600);       // get component deg/min/sec
                m = Math.floor(sec / 60) % 60;
                s = (sec % 60).toFixed(dp);       // pad with trailing zeros
                if (d < 100) d = '0' + d;           // pad with leading zeros
                if (d < 10) d = '0' + d;
                if (m < 10) m = '0' + m;
                if (s < 10) s = '0' + s;
                dms = d + '°' + m + '′' + s + '″';
                break;
        }

        return dms;
    };


    /**
     * Converts numeric degrees to deg/min/sec latitude (2-digit degrees, suffixed with N/S).
     *
     * @param   {number} deg - Degrees to be formatted as specified.
     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.
     * @returns {string} Degrees formatted as deg/min/secs according to specified format.
     */
    Dms.toLat = function (deg, format, dp) {
        var lat = Dms.toDMS(deg, format, dp);
        return lat === null ? '–' : lat.slice(1) + (deg < 0 ? 'S' : 'N');  // knock off initial '0' for lat!
    };


    /**
     * Convert numeric degrees to deg/min/sec longitude (3-digit degrees, suffixed with E/W)
     *
     * @param   {number} deg - Degrees to be formatted as specified.
     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.
     * @returns {string} Degrees formatted as deg/min/secs according to specified format.
     */
    Dms.toLon = function (deg, format, dp) {
        var lon = Dms.toDMS(deg, format, dp);
        return lon === null ? '–' : lon + (deg < 0 ? 'W' : 'E');
    };


    /**
     * Converts numeric degrees to deg/min/sec as a bearing (0°..360°)
     *
     * @param   {number} deg - Degrees to be formatted as specified.
     * @param   {string} [format=dms] - Return value as 'd', 'dm', 'dms' for deg, deg+min, deg+min+sec.
     * @param   {number} [dp=0|2|4] - Number of decimal places to use – default 0 for dms, 2 for dm, 4 for d.
     * @returns {string} Degrees formatted as deg/min/secs according to specified format.
     */
    Dms.toBrng = function (deg, format, dp) {
        deg = (Number(deg) + 360) % 360;  // normalise -ve values to 180°..360°
        var brng = Dms.toDMS(deg, format, dp);
        return brng === null ? '–' : brng.replace('360', '0');  // just in case rounding took us up to 360°!
    };


    /**
     * Returns compass point (to given precision) for supplied bearing.
     *
     * @param   {number} bearing - Bearing in degrees from north.
     * @param   {number} [precision=3] - Precision (cardinal / intercardinal / secondary-intercardinal).
     * @returns {string} Compass point for supplied bearing.
     *
     * @example
     *   var point = Dms.compassPoint(24);    // point = 'NNE'
     *   var point = Dms.compassPoint(24, 1); // point = 'N'
     */
    Dms.compassPoint = function (bearing, precision) {
        if (precision === undefined) precision = 3;
        // note precision = max length of compass point; it could be extended to 4 for quarter-winds
        // (eg NEbN), but I think they are little used

        bearing = ((bearing % 360) + 360) % 360; // normalise to 0..360

        var point;

        switch (precision) {
            case 1: // 4 compass points
                switch (Math.round(bearing * 4 / 360) % 4) {
                    case 0:
                        point = 'N';
                        break;
                    case 1:
                        point = 'E';
                        break;
                    case 2:
                        point = 'S';
                        break;
                    case 3:
                        point = 'W';
                        break;
                }
                break;
            case 2: // 8 compass points
                switch (Math.round(bearing * 8 / 360) % 8) {
                    case 0:
                        point = 'N';
                        break;
                    case 1:
                        point = 'NE';
                        break;
                    case 2:
                        point = 'E';
                        break;
                    case 3:
                        point = 'SE';
                        break;
                    case 4:
                        point = 'S';
                        break;
                    case 5:
                        point = 'SW';
                        break;
                    case 6:
                        point = 'W';
                        break;
                    case 7:
                        point = 'NW';
                        break;
                }
                break;
            case 3: // 16 compass points
                switch (Math.round(bearing * 16 / 360) % 16) {
                    case  0:
                        point = 'N';
                        break;
                    case  1:
                        point = 'NNE';
                        break;
                    case  2:
                        point = 'NE';
                        break;
                    case  3:
                        point = 'ENE';
                        break;
                    case  4:
                        point = 'E';
                        break;
                    case  5:
                        point = 'ESE';
                        break;
                    case  6:
                        point = 'SE';
                        break;
                    case  7:
                        point = 'SSE';
                        break;
                    case  8:
                        point = 'S';
                        break;
                    case  9:
                        point = 'SSW';
                        break;
                    case 10:
                        point = 'SW';
                        break;
                    case 11:
                        point = 'WSW';
                        break;
                    case 12:
                        point = 'W';
                        break;
                    case 13:
                        point = 'WNW';
                        break;
                    case 14:
                        point = 'NW';
                        break;
                    case 15:
                        point = 'NNW';
                        break;
                }
                break;
            default:
                throw new RangeError('Precision must be between 1 and 3');
        }

        return point;
    };


    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */


    /** Polyfill String.trim for old browsers
     *  (q.v. blog.stevenlevithan.com/archives/faster-trim-javascript) */
    if (String.prototype.trim === undefined) {
        String.prototype.trim = function () {
            return String(this).replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        };
    }


    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    if (typeof module != 'undefined' && module.exports) module.exports = Dms; // CommonJS (Node)
    if (typeof define == 'function' && define.amd) define([], function () {
        return Dms;
    }); // AMD
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    /* Geodesy tools for an ellipsoidal earth model         (c) Chris Veness 2005-2015 / MIT Licence  */
    /*                                                                                                */
    /* Includes methods for converting lat/lon coordinates between different coordinate systems.      */
    /*   - www.movable-type.co.uk/scripts/latlong-convert-coords.html                                 */
    /*                                                                                                */
    /*  Usage: to eg convert WGS 84 coordinate to OSGB coordinate:                                    */
    /*   - var wgs84 = new LatLon(latWGS84, lonWGS84, LatLon.datum.WGS84);                            */
    /*   - var osgb = wgs84.convertDatum(LatLon.datum.OSGB36);                                        */
    /*   - var latOSGB = osgb.lat, lonOSGB = osgb.lon;                                                */
    /*                                                                                                */
    /*  q.v. Ordnance Survey 'A guide to coordinate systems in Great Britain' Section 6               */
    /*   - www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf           */
    /*                                                                                                */
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    'use strict';
    if (typeof module != 'undefined' && module.exports) var Vector3d = require('./vector3d.js'); // CommonJS (Node)
    if (typeof module != 'undefined' && module.exports) var Dms = require('./dms.js'); // CommonJS (Node)


    /**
     * Creates lat/lon (polar) point with latitude & longitude values, on a specified datum.
     *
     * @classdesc Library of geodesy functions for operations on an ellipsoidal earth model.
     * @requires Dms from 'dms.js'
     *
     * @constructor
     * @param {number}       lat - Geodetic latitude in degrees.
     * @param {number}       lon - Longitude in degrees.
     * @param {LatLon.datum} [datum=WGS84] - Datum this point is defined within.
     *
     * @example
     *     var p1 = new LatLon(51.4778, -0.0016, LatLon.datum.WGS84);
     */
    function LatLon(lat, lon, datum) {
        // allow instantiation without 'new'
        if (!(this instanceof LatLon)) return new LatLon(lat, lon, datum);

        if (datum === undefined) datum = LatLon.datum.WGS84;

        this.lat = Number(lat);
        this.lon = Number(lon);
        this.datum = datum;
    }


    /**
     * Ellipsoid parameters; major axis (a), minor axis (b), and flattening (f) for each ellipsoid.
     */
    LatLon.ellipsoid = {
        WGS84: {a: 6378137, b: 6356752.31425, f: 1 / 298.257223563},
        GRS80: {a: 6378137, b: 6356752.31414, f: 1 / 298.257222101},
        Airy1830: {a: 6377563.396, b: 6356256.909, f: 1 / 299.3249646},
        AiryModified: {a: 6377340.189, b: 6356034.448, f: 1 / 299.3249646},
        Intl1924: {a: 6378388, b: 6356911.946, f: 1 / 297},
        Bessel1841: {a: 6377397.155, b: 6356078.963, f: 1 / 299.152815351},
    };

    /**
     * Datums; with associated *ellipsoid* and Helmert *transform* parameters to convert from WGS 84
     * into given datum.
     *
     * More are available from earth-info.nga.mil/GandG/coordsys/datums/NATO_DT.pdf,
     * www.fieldenmaps.info/cconv/web/cconv_params.js
     */
    LatLon.datum = {
        /* eslint key-spacing: 0, comma-dangle: 0 */
        WGS84: {
            ellipsoid: LatLon.ellipsoid.WGS84,
            transform: {
                tx: 0.0, ty: 0.0, tz: 0.0,    // m
                rx: 0.0, ry: 0.0, rz: 0.0,    // sec
                s: 0.0
            }                                  // ppm
        },
        NAD83: { // (2009); functionally ≡ WGS84 - www.uvm.edu/giv/resources/WGS84_NAD83.pdf
            ellipsoid: LatLon.ellipsoid.GRS80,
            transform: {
                tx: 1.004, ty: -1.910, tz: -0.515,  // m
                rx: 0.0267, ry: 0.00034, rz: 0.011,  // sec
                s: -0.0015
            }                               // ppm
        }, // note: if you *really* need to convert WGS84<->NAD83, you need more knowledge than this!
        OSGB36: { // www.ordnancesurvey.co.uk/docs/support/guide-coordinate-systems-great-britain.pdf
            ellipsoid: LatLon.ellipsoid.Airy1830,
            transform: {
                tx: -446.448, ty: 125.157, tz: -542.060,  // m
                rx: -0.1502, ry: -0.2470, rz: -0.8421, // sec
                s: 20.4894
            }                               // ppm
        },
        ED50: { // og.decc.gov.uk/en/olgs/cms/pons_and_cop/pons/pon4/pon4.aspx
            ellipsoid: LatLon.ellipsoid.Intl1924,
            transform: {
                tx: 89.5, ty: 93.8, tz: 123.1,    // m
                rx: 0.0, ry: 0.0, rz: 0.156,  // sec
                s: -1.2
            }                                  // ppm
        },
        Irl1975: { // osi.ie/OSI/media/OSI/Content/Publications/transformations_booklet.pdf
            ellipsoid: LatLon.ellipsoid.AiryModified,
            transform: {
                tx: -482.530, ty: 130.596, tz: -564.557,  // m
                rx: -1.042, ry: -0.214, rz: -0.631,  // sec
                s: -8.150
            }                                // ppm
        }, // note: many sources have opposite sign to rotations - to be checked!
        TokyoJapan: { // www.geocachingtoolbox.com?page=datumEllipsoidDetails
            ellipsoid: LatLon.ellipsoid.Bessel1841,
            transform: {
                tx: 148, ty: -507, tz: -685,      // m
                rx: 0, ry: 0, rz: 0,      // sec
                s: 0
            }                                    // ppm
        }
    };


    /**
     * Converts ‘this’ lat/lon coordinate to new coordinate system.
     *
     * @param   {LatLon.datum} toDatum - Datum this coordinate is to be converted to.
     * @returns {LatLon} This point converted to new datum.
     *
     * @example
     *     var pWGS84 = new LatLon(51.4778, -0.0016, LatLon.datum.WGS84);
     *     var pOSGB = pWGS84.convertDatum(LatLon.datum.OSGB36); // pOSGB.toString(): 51.4773°N, 000.0000°E
     */
    LatLon.prototype.convertDatum = function (toDatum) {
        var oldLatLon = this;
        var transform;

        if (oldLatLon.datum == LatLon.datum.WGS84) {
            // converting from WGS 84
            transform = toDatum.transform;
        }
        if (toDatum == LatLon.datum.WGS84) {
            // converting to WGS 84; use inverse transform (don't overwrite original!)
            transform = {};
            for (var param in oldLatLon.datum.transform) {
                if (oldLatLon.datum.transform.hasOwnProperty(param)) {
                    transform[param] = -oldLatLon.datum.transform[param];
                }
            }
        }
        if (transform === undefined) {
            // neither this.datum nor toDatum are WGS84: convert this to WGS84 first
            oldLatLon = this.convertDatum(LatLon.datum.WGS84);
            transform = toDatum.transform;
        }

        var cartesian = oldLatLon.toCartesian();         // convert polar to cartesian...
        cartesian = cartesian.applyTransform(transform); // ...apply transform...
        var newLatLon = cartesian.toLatLonE(toDatum);    // ...and convert cartesian to polar

        return newLatLon;
    };


    /**
     * Converts ‘this’ point from (geodetic) latitude/longitude coordinates to (geocentric) cartesian
     * (x/y/z) coordinates.
     *
     * @returns {Vector3d} Vector pointing to lat/lon point, with x, y, z in metres from earth centre.
     */
    LatLon.prototype.toCartesian = function () {
        var φ = this.lat.toRadians(), λ = this.lon.toRadians();
        var h = 0; // height above ellipsoid - not currently used
        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b;

        var sinφ = Math.sin(φ), cosφ = Math.cos(φ);
        var sinλ = Math.sin(λ), cosλ = Math.cos(λ);

        var eSq = (a * a - b * b) / (a * a);
        var ν = a / Math.sqrt(1 - eSq * sinφ * sinφ);

        var x = (ν + h) * cosφ * cosλ;
        var y = (ν + h) * cosφ * sinλ;
        var z = ((1 - eSq) * ν + h) * sinφ;

        var point = new Vector3d(x, y, z);

        return point;
    };


    /**
     * Converts ‘this’ (geocentric) cartesian (x/y/z) point to (ellipsoidal geodetic) latitude/longitude
     * coordinates on specified datum.
     *
     * Uses Bowring’s (1985) formulation for μm precision.
     *
     * @param {LatLon.datum.transform} datum - Datum to use when converting point.
     */
    Vector3d.prototype.toLatLonE = function (datum) {
        var x = this.x, y = this.y, z = this.z;
        var a = datum.ellipsoid.a, b = datum.ellipsoid.b;

        var e2 = (a * a - b * b) / (a * a); // 1st eccentricity squared
        var ε2 = (a * a - b * b) / (b * b); // 2nd eccentricity squared
        var p = Math.sqrt(x * x + y * y); // distance from minor axis
        var R = Math.sqrt(p * p + z * z); // polar radius

        // parametric latitude (Bowring eqn 17, replacing tanβ = z·a / p·b)
        var tanβ = (b * z) / (a * p) * (1 + ε2 * b / R);
        var sinβ = tanβ / Math.sqrt(1 + tanβ * tanβ);
        var cosβ = sinβ / tanβ;

        // geodetic latitude (Bowring eqn 18)
        var φ = Math.atan2(z + ε2 * b * sinβ * sinβ * sinβ,
                p - e2 * a * cosβ * cosβ * cosβ);

        // longitude
        var λ = Math.atan2(y, x);

        // height above ellipsoid (Bowring eqn 7) [not currently used]
        var sinφ = Math.sin(φ), cosφ = Math.cos(φ);
        var ν = a / Math.sqrt(1 - e2 * sinφ * sinφ); // length of the normal terminated by the minor axis
        var h = p * cosφ + z * sinφ - (a * a / ν);

        var point = new LatLon(φ.toDegrees(), λ.toDegrees(), datum);

        return point;
    };

    /**
     * Applies Helmert transform to ‘this’ point using transform parameters t.
     *
     * @private
     * @param {LatLon.datum.transform} t - Transform to apply to this point.
     */
    Vector3d.prototype.applyTransform = function (t) {
        var x1 = this.x, y1 = this.y, z1 = this.z;

        var tx = t.tx, ty = t.ty, tz = t.tz;
        var rx = (t.rx / 3600).toRadians(); // normalise seconds to radians
        var ry = (t.ry / 3600).toRadians(); // normalise seconds to radians
        var rz = (t.rz / 3600).toRadians(); // normalise seconds to radians
        var s1 = t.s / 1e6 + 1;             // normalise ppm to (s+1)

        // apply transform
        var x2 = tx + x1 * s1 - y1 * rz + z1 * ry;
        var y2 = ty + x1 * rz + y1 * s1 - z1 * rx;
        var z2 = tz - x1 * ry + y1 * rx + z1 * s1;

        var point = new Vector3d(x2, y2, z2);

        return point;
    };


    /**
     * Returns a string representation of ‘this’ point, formatted as degrees, degrees+minutes, or
     * degrees+minutes+seconds.
     *
     * @param   {string} [format=dms] - Format point as 'd', 'dm', 'dms'.
     * @param   {number} [dp=0|2|4] - Number of decimal places to use - default 0 for dms, 2 for dm, 4 for d.
     * @returns {string} Comma-separated latitude/longitude.
     */
    LatLon.prototype.toString = function (format, dp) {
        return Dms.toLat(this.lat, format, dp) + ', ' + Dms.toLon(this.lon, format, dp);
    };


    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    /** Extend Number object with method to convert numeric degrees to radians */
    if (Number.prototype.toRadians === undefined) {
        Number.prototype.toRadians = function () {
            return this * Math.PI / 180;
        };
    }

    /** Extend Number object with method to convert radians to numeric (signed) degrees */
    if (Number.prototype.toDegrees === undefined) {
        Number.prototype.toDegrees = function () {
            return this * 180 / Math.PI;
        };
    }

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)
    if (typeof module != 'undefined' && module.exports) module.exports.Vector3d = Vector3d; // CommonJs (Node)
    if (typeof define == 'function' && define.amd) define([], function () {
        return LatLon;
    }); // AMD
    if (typeof define == 'function' && define.amd) define([], function () {
        return Vector3d;
    }); // AMD??
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    /* Vincenty Direct and Inverse Solution of Geodesics on the Ellipsoid (c) Chris Veness 2002-2015  */
    /*                                                                                   MIT Licence  */
    /*                                                                                                */
    /* from: T Vincenty, "Direct and Inverse Solutions of Geodesics on the Ellipsoid with application */
    /*       of nested equations", Survey Review, vol XXIII no 176, 1975                              */
    /*       http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf                                             */
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    'use strict';
    if (typeof module != 'undefined' && module.exports) var LatLon = require('./latlon-ellipsoidal.js'); // CommonJS (Node)


    /**
     * Direct and inverse solutions of geodesics on the ellipsoid using Vincenty formulae
     */


    /**
     * Returns the distance between ‘this’ point and destination point along a geodesic, using Vincenty
     * inverse solution.
     *
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @returns (Number} Distance in metres between points or NaN if failed to converge.
     *
     * @example
     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);
     *   var d = p1.distanceTo(p2); // d: 969954.166
     */
    LatLon.prototype.distanceTo = function (point) {
        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

        try {
            return this.inverse(point).distance;
        } catch (e) {
            return NaN; // failed to converge
        }
    };


    /**
     * Returns the initial bearing (forward azimuth) to travel along a geodesic from ‘this’ point to the
     * specified point, using Vincenty inverse solution.
     *
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @returns {number}  initial Bearing in degrees from north (0°..360°) or NaN if failed to converge.
     *
     * @example
     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);
     *   var b1 = p1.initialBearingTo(p2); // b1.toFixed(4): 9.1419
     */
    LatLon.prototype.initialBearingTo = function (point) {
        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

        try {
            return this.inverse(point).initialBearing;
        } catch (e) {
            return NaN; // failed to converge
        }
    };


    /**
     * Returns the final bearing (reverse azimuth) having travelled along a geodesic from ‘this’ point
     * to the specified point, using Vincenty inverse solution.
     *
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @returns {number}  Initial bearing in degrees from north (0°..360°) or NaN if failed to converge.
     *
     * @example
     *   var p1 = new LatLon(50.06632, -5.71475), p2 = new LatLon(58.64402, -3.07009);
     *   var b2 = p1.finalBearingTo(p2); // b2.toFixed(4): 11.2972
     */
    LatLon.prototype.finalBearingTo = function (point) {
        if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');

        try {
            return this.inverse(point).finalBearing;
        } catch (e) {
            return NaN; // failed to converge
        }
    };


    /**
     * Returns the destination point having travelled the given distance along a geodesic given by
     * initial bearing from ‘this’ point, using Vincenty direct solution.
     *
     * @param   {number} distance - Distance travelled along the geodesic in metres.
     * @param   {number} initialBearing - Initial bearing in degrees from north.
     * @returns {LatLon} Destination point.
     *
     * @example
     *   var p1 = new LatLon(-37.95103, 144.42487);
     *   var p2 = p1.destinationPoint(54972.271, 306.86816); // p2.toString(): 37.6528°S, 143.9265°E
     */
    LatLon.prototype.destinationPoint = function (distance, initialBearing) {
        return this.direct(Number(distance), Number(initialBearing)).point;
    };


    /**
     * Returns the final bearing (reverse azimuth) having travelled along a geodesic given by initial
     * bearing for a given distance from ‘this’ point, using Vincenty direct solution.
     *
     * @param   {number} distance - Distance travelled along the geodesic in metres.
     * @param   {LatLon} initialBearing - Initial bearing in degrees from north.
     * @returns {number} Final bearing in degrees from north (0°..360°).
     *
     * @example
     *   var p1 = new LatLon(-37.95103, 144.42487);
     *   var b2 = p1.finalBearingOn(306.86816, 54972.271); // b2.toFixed(4): 307.1736
     */
    LatLon.prototype.finalBearingOn = function (distance, initialBearing) {
        return this.direct(Number(distance), Number(initialBearing)).finalBearing;
    };


    /**
     * Vincenty direct calculation.
     *
     * @private
     * @param   {number} distance - Distance along bearing in metres.
     * @param   {number} initialBearing - Initial bearing in degrees from north.
     * @returns (Object} Object including point (destination point), finalBearing.
     * @throws  {Error}  If formula failed to converge.
     */
    LatLon.prototype.direct = function (distance, initialBearing) {
        var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();
        var α1 = initialBearing.toRadians();
        var s = distance;

        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;

        var sinα1 = Math.sin(α1);
        var cosα1 = Math.cos(α1);

        var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
        var σ1 = Math.atan2(tanU1, cosα1);
        var sinα = cosU1 * sinα1;
        var cosSqα = 1 - sinα * sinα;
        var uSq = cosSqα * (a * a - b * b) / (b * b);
        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));

        var cos2σM, sinσ, cosσ, Δσ;

        var σ = s / (b * A), σʹ, iterations = 0;
        do {
            cos2σM = Math.cos(2 * σ1 + σ);
            sinσ = Math.sin(σ);
            cosσ = Math.cos(σ);
            Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
                    B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));
            σʹ = σ;
            σ = s / (b * A) + Δσ;
        } while (Math.abs(σ - σʹ) > 1e-12 && ++iterations < 200);
        if (iterations >= 200) throw new Error('Formula failed to converge'); // not possible?

        var x = sinU1 * sinσ - cosU1 * cosσ * cosα1;
        var φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1 - f) * Math.sqrt(sinα * sinα + x * x));
        var λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);
        var C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));
        var L = λ - (1 - C) * f * sinα *
                (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
        var λ2 = (λ1 + L + 3 * Math.PI) % (2 * Math.PI) - Math.PI;  // normalise to -180...+180

        var α2 = Math.atan2(sinα, -x);
        α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360

        return {
            point: new LatLon(φ2.toDegrees(), λ2.toDegrees(), this.datum),
            finalBearing: α2.toDegrees(),
        };
    };


    /**
     * Vincenty inverse calculation.
     *
     * @private
     * @param   {LatLon} point - Latitude/longitude of destination point.
     * @returns {Object} Object including istance, initialBearing, finalBearing.
     * @throws  {Error}  If formula failed to converge.
     */
    LatLon.prototype.inverse = function (point) {
        var p1 = this, p2 = point;
        var φ1 = p1.lat.toRadians(), λ1 = p1.lon.toRadians();
        var φ2 = p2.lat.toRadians(), λ2 = p2.lon.toRadians();

        var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;

        var L = λ2 - λ1;
        var tanU1 = (1 - f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1)), sinU1 = tanU1 * cosU1;
        var tanU2 = (1 - f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2 * tanU2)), sinU2 = tanU2 * cosU2;

        var sinλ, cosλ, sinSqσ, sinσ, cosσ, σ, sinα, cosSqα, cos2σM, C;

        var λ = L, λʹ, iterations = 0;
        do {
            sinλ = Math.sin(λ);
            cosλ = Math.cos(λ);
            sinSqσ = (cosU2 * sinλ) * (cosU2 * sinλ) + (cosU1 * sinU2 - sinU1 * cosU2 * cosλ) * (cosU1 * sinU2 - sinU1 * cosU2 * cosλ);
            sinσ = Math.sqrt(sinSqσ);
            if (sinσ == 0) return 0;  // co-incident points
            cosσ = sinU1 * sinU2 + cosU1 * cosU2 * cosλ;
            σ = Math.atan2(sinσ, cosσ);
            sinα = cosU1 * cosU2 * sinλ / sinσ;
            cosSqα = 1 - sinα * sinα;
            cos2σM = cosσ - 2 * sinU1 * sinU2 / cosSqα;
            if (isNaN(cos2σM)) cos2σM = 0;  // equatorial line: cosSqα=0 (§6)
            C = f / 16 * cosSqα * (4 + f * (4 - 3 * cosSqα));
            λʹ = λ;
            λ = L + (1 - C) * f * sinα * (σ + C * sinσ * (cos2σM + C * cosσ * (-1 + 2 * cos2σM * cos2σM)));
        } while (Math.abs(λ - λʹ) > 1e-12 && ++iterations < 200);
        if (iterations >= 200) throw new Error('Formula failed to converge');

        var uSq = cosSqα * (a * a - b * b) / (b * b);
        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        var Δσ = B * sinσ * (cos2σM + B / 4 * (cosσ * (-1 + 2 * cos2σM * cos2σM) -
                B / 6 * cos2σM * (-3 + 4 * sinσ * sinσ) * (-3 + 4 * cos2σM * cos2σM)));

        var s = b * A * (σ - Δσ);

        var α1 = Math.atan2(cosU2 * sinλ, cosU1 * sinU2 - sinU1 * cosU2 * cosλ);
        var α2 = Math.atan2(cosU1 * sinλ, -sinU1 * cosU2 + cosU1 * sinU2 * cosλ);

        α1 = (α1 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360
        α2 = (α2 + 2 * Math.PI) % (2 * Math.PI); // normalise to 0...360

        s = Number(s.toFixed(3)); // round to 1mm precision
        return {distance: s, initialBearing: α1.toDegrees(), finalBearing: α2.toDegrees()};
    };


    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    /** Extend Number object with method to convert numeric degrees to radians */
    if (Number.prototype.toRadians === undefined) {
        Number.prototype.toRadians = function () {
            return this * Math.PI / 180;
        };
    }

    /** Extend Number object with method to convert radians to numeric (signed) degrees */
    if (Number.prototype.toDegrees === undefined) {
        Number.prototype.toDegrees = function () {
            return this * 180 / Math.PI;
        };
    }

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)
    if (typeof define == 'function' && define.amd) define([], function () {
        return LatLon;
    }); // AMD
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    /*  Vector handling functions                           (c) Chris Veness 2011-2015 / MIT Licence  */
    /*                                                                                                */
    /*  These are generic 3-d vector manipulation routines.                                           */
    /*                                                                                                */
    /*  In a geodesy context, these may be used to represent:                                         */
    /*   - n-vector representing a normal to point on Earth's surface                                 */
    /*   - earth-centered, earth fixed vector (= n-vector for spherical model)                        */
    /*   - great circle normal to vector                                                              */
    /*   - motion vector on Earth's surface                                                           */
    /*   - etc                                                                                        */
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

    'use strict';


    /**
     * Creates a 3-d vector.
     *
     * The vector may be normalised, or use x/y/z values for eg height relative to the sphere or
     * ellipsoid, distance from earth centre, etc.
     *
     * @classdesc Tools for manipulating 3-d vectors, to support various latitude/longitude functions.
     *
     * @constructor
     * @param {number} x - X component of vector.
     * @param {number} y - Y component of vector.
     * @param {number} z - Z component of vector.
     */
    function Vector3d(x, y, z) {
        // allow instantiation without 'new'
        if (!(this instanceof Vector3d)) return new Vector3d(x, y, z);

        this.x = Number(x);
        this.y = Number(y);
        this.z = Number(z);
    }


    /**
     * Adds supplied vector to ‘this’ vector.
     *
     * @param   {Vector3d} v - Vector to be added to this vector.
     * @returns {Vector3d} Vector representing sum of this and v.
     */
    Vector3d.prototype.plus = function (v) {
        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');

        return new Vector3d(this.x + v.x, this.y + v.y, this.z + v.z);
    };


    /**
     * Subtracts supplied vector from ‘this’ vector.
     *
     * @param   {Vector3d} v - Vector to be subtracted from this vector.
     * @returns {Vector3d} Vector representing difference between this and v.
     */
    Vector3d.prototype.minus = function (v) {
        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');

        return new Vector3d(this.x - v.x, this.y - v.y, this.z - v.z);
    };


    /**
     * Multiplies ‘this’ vector by a scalar value.
     *
     * @param   {number}   x - Factor to multiply this vector by.
     * @returns {Vector3d} Vector scaled by x.
     */
    Vector3d.prototype.times = function (x) {
        x = Number(x);

        return new Vector3d(this.x * x, this.y * x, this.z * x);
    };


    /**
     * Divides ‘this’ vector by a scalar value.
     *
     * @param   {number}   x - Factor to divide this vector by.
     * @returns {Vector3d} Vector divided by x.
     */
    Vector3d.prototype.dividedBy = function (x) {
        x = Number(x);

        return new Vector3d(this.x / x, this.y / x, this.z / x);
    };


    /**
     * Multiplies ‘this’ vector by the supplied vector using dot (scalar) product.
     *
     * @param   {Vector3d} v - Vector to be dotted with this vector.
     * @returns {number} Dot product of ‘this’ and v.
     */
    Vector3d.prototype.dot = function (v) {
        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');

        return this.x * v.x + this.y * v.y + this.z * v.z;
    };


    /**
     * Multiplies ‘this’ vector by the supplied vector using cross (vector) product.
     *
     * @param   {Vector3d} v - Vector to be crossed with this vector.
     * @returns {Vector3d} Cross product of ‘this’ and v.
     */
    Vector3d.prototype.cross = function (v) {
        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');

        var x = this.y * v.z - this.z * v.y;
        var y = this.z * v.x - this.x * v.z;
        var z = this.x * v.y - this.y * v.x;

        return new Vector3d(x, y, z);
    };


    /**
     * Negates a vector to point in the opposite direction
     *
     * @returns {Vector3d} Negated vector.
     */
    Vector3d.prototype.negate = function () {
        return new Vector3d(-this.x, -this.y, -this.z);
    };


    /**
     * Length (magnitude or norm) of ‘this’ vector
     *
     * @returns {number} Magnitude of this vector.
     */
    Vector3d.prototype.length = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };


    /**
     * Normalizes a vector to its unit vector
     * – if the vector is already unit or is zero magnitude, this is a no-op.
     *
     * @returns {Vector3d} Normalised version of this vector.
     */
    Vector3d.prototype.unit = function () {
        var norm = this.length();
        if (norm == 1) return this;
        if (norm == 0) return this;

        var x = this.x / norm;
        var y = this.y / norm;
        var z = this.z / norm;

        return new Vector3d(x, y, z);
    };


    /**
     * Calculates the angle between ‘this’ vector and supplied vector.
     *
     * @param   {Vector3d} v
     * @param   {Vector3d} [vSign] - If supplied (and out of plane of this and v), angle is signed +ve if
     *     this->v is clockwise looking along vSign, -ve in opposite direction (otherwise unsigned angle).
     * @returns {number} Angle (in radians) between this vector and supplied vector.
     */
    Vector3d.prototype.angleTo = function (v, vSign) {
        if (!(v instanceof Vector3d)) throw new TypeError('v is not Vector3d object');

        var sinθ = this.cross(v).length();
        var cosθ = this.dot(v);

        if (vSign !== undefined) {
            if (!(vSign instanceof Vector3d)) throw new TypeError('vSign is not Vector3d object');
            // use vSign as reference to get sign of sinθ
            sinθ = this.cross(v).dot(vSign) < 0 ? -sinθ : sinθ;
        }

        return Math.atan2(sinθ, cosθ);
    };


    /**
     * Rotates ‘this’ point around an axis by a specified angle.
     *
     * @param   {Vector3d} axis - The axis being rotated around.
     * @param   {number}   theta - The angle of rotation (in radians).
     * @returns {Vector3d} The rotated point.
     */
    Vector3d.prototype.rotateAround = function (axis, theta) {
        if (!(axis instanceof Vector3d)) throw new TypeError('axis is not Vector3d object');

        // en.wikipedia.org/wiki/Rotation_matrix#Rotation_matrix_from_axis_and_angle
        // en.wikipedia.org/wiki/Quaternions_and_spatial_rotation#Quaternion-derived_rotation_matrix
        var p1 = this.unit();
        var p = [p1.x, p1.y, p1.z]; // the point being rotated
        var a = axis.unit();          // the axis being rotated around
        var s = Math.sin(theta);
        var c = Math.cos(theta);
        // quaternion-derived rotation matrix
        var q = [
            [a.x * a.x * (1 - c) + c, a.x * a.y * (1 - c) - a.z * s, a.x * a.z * (1 - c) + a.y * s],
            [a.y * a.x * (1 - c) + a.z * s, a.y * a.y * (1 - c) + c, a.y * a.z * (1 - c) - a.x * s],
            [a.z * a.x * (1 - c) - a.y * s, a.z * a.y * (1 - c) + a.x * s, a.z * a.z * (1 - c) + c],
        ];
        // multiply q × p
        var qp = [0, 0, 0];
        for (var i = 0; i < 3; i++) {
            for (var j = 0; j < 3; j++) {
                qp[i] += q[i][j] * p[j];
            }
        }
        var p2 = new Vector3d(qp[0], qp[1], qp[2]);
        return p2;
        // qv en.wikipedia.org/wiki/Rodrigues'_rotation_formula...
    };


    /**
     * String representation of vector.
     *
     * @param   {number} [precision=3] - Number of decimal places to be used.
     * @returns {string} Vector represented as [x,y,z].
     */
    Vector3d.prototype.toString = function (precision) {
        var p = (precision === undefined) ? 3 : Number(precision);

        var str = '[' + this.x.toFixed(p) + ',' + this.y.toFixed(p) + ',' + this.z.toFixed(p) + ']';

        return str;
    };


    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
    if (typeof module != 'undefined' && module.exports) module.exports = Vector3d; // CommonJS (Node)
    if (typeof define == 'function' && define.amd) define([], function () {
        return Vector3d;
    }); // AMD
    /**
     * (c) Abid Mohammed 2015
     * Apache Licence
     *
     *Usage - To convert an array of LatLons X into an array of LatLons Y such that all LatLons in Y are at a Distance D(fineDistance) from each other.
     *
     */
    'use strict';
    if (typeof module != 'undefined' && module.exports) var LatLon = require('./latlon-ellipsoidal.js'); // CommonJS (Node)

    function CalculateFinerLatLngs(latlons, fineDistance) {
        var fineShapePoints = [];
        fineShapePoints.push(latlons[0]);
        for (var i = 1; i < latlons.length; i++) {
            var distanceBetweenLatLon = latlons[i - 1].distanceTo(latlons[i]);
            var bearingBetweenLatLon = latlons[i - 1].initialBearingTo(latlons[i]);
            if (distanceBetweenLatLon <= fineDistance) {
                fineShapePoints.push(latlons[i]);
            } else {
                var div = 1;
                var remainingDist = distanceBetweenLatLon;
                while (remainingDist >= 0) {
                    var toD = div++ * fineDistance;
                    if (remainingDist - fineDistance >= 0) {
                        var nextPoint = latlons[i - 1].direct(toD, bearingBetweenLatLon);
                        fineShapePoints.push(nextPoint);
                    } else {
                        fineShapePoints.push(latlons[i]);
                    }
                    remainingDist = remainingDist - fineDistance;
                }
            }
        }
        return fineShapePoints;
    }
    /**
     * (c) Abid Mohammed 2015
     *  Apache Licence
     **/

    function msToHours(ms) {
        var seconds = ms / 1000;
        var hours = parseInt(seconds / 3600);
        seconds = seconds % 3600;
        var minutes = (seconds / 60);
        var result = hours + (minutes / 60);
        return result;
    }

    function calcSpeed(dist, time_in_msec) {
        return dist / msToHours(time_in_msec);
    }

    function calcTimeInMilliSec(speed, distance) {
        return (distance / speed) * 60 * 60 * 1000;
    }

    function calcDistTravelled(speed, time_in_msec) {
        return speed * msToHours(time_in_msec);
    }

    function createVehicleMarkerCanvas(elementId) {
        var vehicleMarkerCanvas = document.getElementById(elementId);
        var vMarkerContext = vehicleMarkerCanvas.getContext('2d');
        vMarkerContext.beginPath();
        vMarkerContext.shadowColor = '#0080FF';
        vMarkerContext.shadowOffsetX = 0;
        vMarkerContext.shadowOffsetY = 0;
        vMarkerContext.shadowBlur = 6;
        vMarkerContext.arc(vehicleMarkerCanvas.width / 2, vehicleMarkerCanvas.height / 2, 8, 0, 2 * Math.PI, false);
        vMarkerContext.fillStyle = '#2ECCFA';
        vMarkerContext.fill();
        vMarkerContext.lineWidth = 1.5;
        vMarkerContext.strokeStyle = 'white';
        vMarkerContext.stroke();
        return vehicleMarkerCanvas;
    }

    function convertRouteIntoFinerLatLngs(route, fineDist) {
        var latlongs = convertRouteToLatLngObjects(route);
        return CalculateFinerLatLngs(latlongs, fineDist);
    }

    function convertRouteToLatLngObjects(route) {
        var latlongs = [];
        route.shape.forEach(function (point) {
            var p = point.split(",");
            latlongs.push(new LatLon(p[0], p[1]));
        });
        return latlongs;
    }

</script>
</body>
</html>